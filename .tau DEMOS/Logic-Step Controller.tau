set charvar off

i1 : bv[8] = in console
o1 : bv[8] = out console

run always (
    // LAYER 1: FAULT & NOISE REJECTION
    // If the current input is a massive spike (Critical High > 0xE0)
    // but the previous two readings were normal/low (< 0xA0), ignore it as a glitch/sensor fault.
    // ACTION: Maintain previous output.
    ((i1[t] > { #xE0 }:bv[8]) && (i1[t-1] < { #xA0 }:bv[8]) && (i1[t-2] < { #xA0 }:bv[8])) ? 
        (o1[t] = o1[t-1]) :

    // LAYER 2: DEADBAND (STABILITY)
    // If input is within +/- 5% of 0.5 (Range 0x78 to 0x88), 
    // force output to neutral (0x80) to stop "hunting".
    ((i1[t] >= { #x78 }:bv[8]) && (i1[t] <= { #x88 }:bv[8])) ? 
        (o1[t] = { #x80 }:bv[8]) :

    // LAYER 3: OVERSHOOT PROTECTION (SOFT LANDING)
    // If we are below target (< 0x78) BUT signal is rising (i1[t] > i1[t-1]),
    // don't apply full power. Apply "Soft High" (0xA0) instead of "Hard High".
    ((i1[t] < { #x78 }:bv[8]) && (i1[t] > i1[t-1])) ? 
        (o1[t] = { #xA0 }:bv[8]) :

    // LAYER 4: UNDERSHOOT PROTECTION (SOFT LANDING)
    // If we are above target (> 0x88) BUT signal is falling (i1[t] < i1[t-1]),
    // don't cut power completely. Apply "Soft Low" (0x60).
    ((i1[t] > { #x88 }:bv[8]) && (i1[t] < i1[t-1])) ? 
        (o1[t] = { #x60 }:bv[8]) :

    // LAYER 5: PROPORTIONAL ZONES (CORE LOGIC)
    
    // Critical High (> 0xC8 / 200): Cut Output to 0
    (i1[t] > { #xC8 }:bv[8]) ? (o1[t] = { #x00 }:bv[8]) :
    
    // Standard High (> 0x96 / 150): Low Output (Cooling)
    (i1[t] > { #x96 }:bv[8]) ? (o1[t] = { #x40 }:bv[8]) :
    
    // Critical Low (< 0x32 / 50): Max Output
    (i1[t] < { #x32 }:bv[8]) ? (o1[t] = { #xFF }:bv[8]) :
    
    // Standard Low (< 0x78 / 120): High Output (Heating)
    // Default fallback
    (o1[t] = { #xC0 }:bv[8])
)